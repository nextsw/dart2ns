server class ExecutableUtil {

    static Boolean isSignatureMatched(MethodDecl on, ValidationContext ctx, PropType _this, String methodName, Boolean isStatic, Boolean isGetter, Boolean isSetter, List<PropType> positionParamTypes, Map<String, PropType> namedParamTypes, List<PropType> typeArguments) {
        if (methodName != on.name) {
            return false;
        }
        if (positionParamTypes == null) {
            return true;
        }
        if (on.positionalParams.length > positionParamTypes.length) {
            return false;
        }
        if (on.namedParams.length < namedParamTypes.length) {
            return false;
        }
        if (on.optionalParams.length < (positionParamTypes.length - on.positionalParams.length)) {
            return false;
        }
        Map<String, PropType> typeVars = createTypeArguments(on, ctx, typeArguments);
        Integer i = 0;
        for (Integer j = 0; i < on.positionalParams.length; i++) {
            MethodParam parameter = on.positionalParams.get(i);
            PropType propType = positionParamTypes.get(i);
            if (!PropTypeUtil.isAssignableFrom(PropTypeUtil.resolveType(_this, null, parameter.dataType.resolvedType, typeVars), propType)) {
                return false;
            }
            i++;
        }
        for (MethodParam p in on.namedParams) {
            PropType propType = namedParamTypes.get(p.name);
            if (propType == null) {
                if (p.required) {
                    return false;
                }
                continue;
            }
            if (!PropTypeUtil.isAssignableFrom(PropTypeUtil.resolveType(_this, null, p.dataType.resolvedType, typeVars), propType)) {
                return false;
            }
        }
        for (Integer j = 0; i < positionParamTypes.length; j++, i++) {
            MethodParam parameter = on.optionalParams.get(j);
            PropType propType = positionParamTypes.get(i);
            if (!PropTypeUtil.isAssignableFrom(PropTypeUtil.resolveType(_this, null, parameter.dataType.resolvedType, typeVars), propType)) {
                return false;
            }
        }
        return true;
    }

    static Boolean canSearchNative(PropType type) {
        return type.types;
    }

    static Map<String, PropType> createTypeArguments(MethodDecl on, ValidationContext ctx, List<PropType> typeArgs) {
        if (ctx == null || typeArgs == null || on.typeVars.isEmpty) {
            return Map();
        }
        Map<String, PropType> result = Map();
        for (TypeVariable t in on.typeVars) {
            List<TypeResolutionPosition> positions = t.positions;
            List<PropType> all = List();
            for (TypeResolutionPosition p in positions) {
                PropType res = getTypeAtPosition(on, ctx, p);
                if (res != null) {
                    all.add(res);
                }
            }
            result.set(t.name, ctx.findSuperType(all));
        }
        //for (Integer x = 0; x < typeArgs.length && x < typeVars.length; x++) {
        //	result.set(typeVars.get(x).name, typeArgs.get(x));
        //}
        return result;
    }

    static PropType getTypeAtPosition(MethodDecl on, ValidationContext ctx, TypeResolutionPosition pos) {
        if(pos.type == TypeResolutionPositionType.RETURN) {
            return getTypeAtPostion(on, ctx, ctx.getExpectedType(), pos.gens);
	    }
        TypeResolutionPositionType type = pos.type;
        switch (type) {
            case NAMED:
                for (MethodParam p in on.namedParams) {
                    if (p.name == pos.name) {
                        return getTypeAtPostion(on, ctx, p.dataType.resolvedType, pos.gens);
                    }
                }

            case OPTIONAL:
                if (pos.index < on.optionalParams.length) {
                    return getTypeAtPostion(on, ctx, on.optionalParams.get(pos.index).dataType.resolvedType, pos.gens);
                }

            case POSITIONAL:
                if (pos.index < on.positionalParams.length) {
                    return getTypeAtPostion(on, ctx, on.positionalParams.get(pos.index).dataType.resolvedType, pos.gens);
                }

            case RETURN:
                return null;

        }
        return null;
    }

    static PropType getTypeAtPostion(MethodDecl on, ValidationContext ctx, PropType type, List<TypeResolutionPosition> gens) {
        if (type == null || gens == null || gens.isEmpty) {
            return type;
        }
        List<PropType> all = List();
        for (TypeResolutionPosition p in gens) {
            if (p.genVar == null) {
                MethodDecl method = PropTypeUtil.findLambdaFunction(type).method;
                PropType pt;
                if (p.type == TypeResolutionPositionType.RETURN) {
                    pt = ExecutableUtil.getTypeAtPostion(method, ctx, method.returnType.resolvedType, p.gens);
                } else {
                    pt = MethodUtil.getTypeAtPosition(method, ctx, p);
                }
                addType(all, pt);
            } else {
                PropType ele = PropTypeUtil.elemenetType(type, p.genVar);
                if (ele != null) {
                    addType(all, getTypeAtPostion(on, ctx, ele, p.gens));
                }
            }
        }
        if (all.isEmpty) {
            return null;
        }
        return ctx.findSuperType(all);
    }

    static void addType(List<PropType> all, PropType type) {
        if (type == null || (type is TypeVariable) || all.contains(type)) {
            return;
        }
        all.add(type);
    }

    static List<PropType> createTypesArray(MethodDecl on, ValidationContext ctx, PropType type, TypeArguments typeArgs) {
        if (typeArgs == null) {
            return List();
        }
        return TypeArgumentsUtil.createTypesArray(typeArgs, ctx);
    }

    static void replaceGenerics(MethodDecl on, ValidationContext ctx, ParameterizedType paraType, MethodDecl executable) {
        executable.name = on.name;
        executable.typeVars = List.from(on.typeVars);
        executable.positionalParams = on.positionalParams.map((t) {
            MethodParam p = MethodParam(
                name: t.name,
                dataType: PropTypeUtil.resolveType(paraType, ctx, t.type, null),
            );
            p.castRequired = t.castRequired;
            p.def = t.def;
            p.instance = p.instance;
            return p;
        }).toList();
        executable.namedParams = on.namedParams.map((t) {
            MethodParam p = MethodParam(
                name: t.name,
                dataType: PropTypeUtil.resolveType(paraType, ctx, t.type, null),
            );
            p.castRequired = t.castRequired;
            p.def = t.def;
            p.instance = p.instance;
            return p;
        }).toList();
        executable.optionalParams = on.optionalParams.map((t) {
            MethodParam p = MethodParam(
                name: t.name,
                dataType: PropTypeUtil.resolveType(paraType, ctx, t.type, null),
            );
            p.castRequired = t.castRequired;
            p.def = t.def;
            p.instance = p.instance;
            return p;
        }).toList();
        executable.body = on.body;
    }
}