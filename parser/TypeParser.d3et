server class TypeParser {

    TypeScanner scanner;

    TypeToken tok;

    TypeToken prevTok;

    TypeToken peekTok;

    TypeToken peekTok2;

    TypeToken peekTok3;

    TypeToken peekTok4;

    Boolean expectingType = false;

    Boolean insideStrInterp = false;

    List<GenError> errors = [];
    
    Dart2NSContext context;

    List<TokenFrame> savedFrames = [];

    static List<String> primitives = ['void', 'bool', 'int', 'double', 'dynamic', 'num', 'var'];
    

    TypeParser(this.context, this.scanner);

    static List<TopDecl> parse(Dart2NSContext context, String content) {
        List<TopDecl> res = [];
        if(content.isEmpty) {
            return res;
        }
        TypeParser p = TypeParser(context, TypeScanner(content));
        p.readFirstToken();
        try {
            while (p.readTopObject(res)) {}
            p.eatComments();
            p.check(TypeKind.Eof);
        } catch(e) {
            D3ELogger.error(e.message);
        }
        res.forEach(i => context.add(i));
        return res;
    }

    static void updateErrorsPath(String prop, List<GenError> errors) {
        errors.forEach((e) {
            e.path = preparePath(prop, e.path);
        });
    }

    static String preparePath(String prop, String path) {
        if (path == null) {
            return prop;
        } else if (path.startsWith('[')) {
            return prop + path;
        }
        return prop + '.' + path;
    }

    Boolean readTopObject(List<TopDecl> list) {
        TypeToken start = tok;
        eatComments();
        TopDecl obj = null;
        List<Annotation> annotations = readAnnotations();
        if (isKey(tok, 'library')) {
            String lib = readLibrary();
            return true;
        } else if (isKey(tok, 'export')) {
            next();
            String path = tok.lit;
            next();
            Export export = context.loadExport(path);
            readExport(export);
            return true;
        } else if(isKey(tok, 'import')) {
            next();
            String path = tok.lit;
            next();
            Import import = context.loadImport(path);
            readImport(import);
            return true;
        } else if (isKey(this.tok, 'part')) {
            if(isKey(this.peekTok, 'of')) {
                next();
                next();
                while(tok.kind != TypeKind.Semicolon) {
                    next();
                }
                next();
                return true;
            }
            next();
            context.loadPart(tok.lit);
            next();
            check(TypeKind.Semicolon);
            return true;
        }
        if (isKey(tok, 'typedef')) {
            obj = readTypeDef(annotations);
        } else if (isKey(tok, 'enum')) {
            obj = readEnum(annotations);
        } else if (tok.kind == TypeKind.Eof) {
            obj = null;
        } else if (isKey(tok, 'class') 
            || isKey(tok, 'abstract')
            || isKey(tok, 'mixin')
            || isKey(tok, 'extension')) {
            obj = readClass(annotations, start);
        } else {
            obj = readClassMember('');
        }
        if(obj != null) {
            list.add(obj);
            return true;
        }
        return false;
    }

    void readExport(Export ex) {
        if(isKey(tok, 'show')) {
            next();
            while(tok.kind != TypeKind.Semicolon) {
                ex.show.add(tok.lit);
                next();
            }
        }
        if(isKey(tok, 'hide')) {
            next();
            while(tok.kind != TypeKind.Semicolon) {
                ex.show.add(tok.lit);
                next();
            }
        }
        check(TypeKind.Semicolon);
    }

    void readImport(Import imp) {
        if(isKey(tok, 'differred')) {
            next();
            imp.differed = true;
        }
        if(isKey(tok, 'as')) {
            next();
            imp.name = checkName();
        }
        if(isKey(tok, 'show')) {
            next();
            while(tok.kind != TypeKind.Semicolon) {
                imp.show.add(tok.lit);
                next();
            }
        }
        if(isKey(tok, 'hide')) {
            next();
            while(tok.kind != TypeKind.Semicolon) {
                imp.show.add(tok.lit);
                next();
            }
        }
        check(TypeKind.Semicolon);
    }

    String readLibrary(){
        next();
        String lib  = checkName();
        while (tok.kind == TypeKind.Dot) {
            next();
            lib += '.' + checkName();
        }
        check(TypeKind.Semicolon);
        return lib;
    }

    List<Annotation> readAnnotations() {
        List<Annotation> res = [];
        while (tok.kind == TypeKind.At) {
            Annotation at = readAnnotation();
            res.add(at);
            at.comments.addAll(eatComments());
        }
        return res;
    }

    Annotation readAnnotation() {
        TypeToken start = tok;
        next();
        String name = checkName();
        MethodCall call = callExpr(name);
        return Annotation(call);
    }

    Enum readEnum(List<Annotation> annotations) {
        TypeToken start = tok;
        checkKey('enum');
        String name = checkName();
        check(TypeKind.Lcbr);
        Enum data = Enum(name);
        data.values.clear();
        while (tok.kind != TypeKind.Rcbr && tok.kind != TypeKind.Eof) {
            eatComments();
            List<Annotation> subAnn = readAnnotations();
            String id = checkName();
            data.values.add(id);
            eatComments();
            if (tok.kind != TypeKind.Comma) {
                break;
            } else {
                next();
                eatComments();
            }
        }
        check(TypeKind.Rcbr);
        data.annotations = annotations;
        return data;
    }

    void checkKey(String key) {
        if (isKey(tok, key)) {
            next();
        } else {
            error('Expected: ' + key + ' found ' + tok.lit);
        }
    }

    Typedef readTypeDef(List<Annotation> annotations) {
        checkKey('typedef');
        DefType type = readDefType();
        FunctionType fnType = null;
        if(tok.kind != TypeKind.Assign) {
            String name = null;
            if(tok.kind == TypeKind.Lpar) {
                name = type.name;
            } else {
                name = checkName();    		
            }
            fnType = readFunctionType(type);
            fnType.name = name;
        } else {
            check(TypeKind.Assign);
            fnType = readType(false) as FunctionType;
        }
        check(TypeKind.Semicolon);
        Typedef def = Typedef(type, fnType);
        def.annotations = annotations;
        return def;
    }

    TypeParams readTypeParams() {
        TypeToken start = tok;
        // Need to call next here to move over the "<"
        check(TypeKind.Lt);
        TypeParams params = TypeParams();
        while (true) {
            if (this.tok.kind == TypeKind.At) {
                readAnnotation();
            }
            if (tok.kind == TypeKind.Gt) {
                break;
            }
            if (tok.kind != TypeKind.Name) {
                return null;
            }
            String name = checkName();
            DataType type = null;
            if (isKey(tok, 'extends')) {
                next();
                type = readType(false);
                if (type == null) {
                    return null;
                }
            }
            params.params.add(TypeParam(
                name: name,
                extendType: type,
            ));
            if (this.tok.kind != TypeKind.Comma) {
                break;
            } else {
                next();
            }
        }
        if (tok.kind != TypeKind.Gt) {
            return null;
        }
        next();
        return params;
    }

    MethodParams readMethodParams(Boolean constructor) {
        check(TypeKind.Lpar);
        MethodParams params = MethodParams();
        while (true) {
            List<Comment> comments = eatComments();
            if (tok.kind == TypeKind.Lsbr) {
                params.optionalParams = readParams(TypeKind.Lsbr, TypeKind.Rsbr, constructor);
            } else if (tok.kind == TypeKind.Lcbr) {
                params.namedParams = readParams(TypeKind.Lcbr, TypeKind.Rcbr, constructor);
            }
            if (tok.kind == TypeKind.Eof || tok.kind == TypeKind.Rpar) {
                break;
            }
            params.positionalParams.add(readParam(constructor));
            if (tok.kind == TypeKind.Comma) {
                next();
            } else {
                break;
            }
        }
        check(TypeKind.Rpar);
        return params;
    }

    List<MethodParam> readParams(TypeKind start, TypeKind end, Boolean constructor) {
        List<MethodParam> params = [];
        check(start);
        while (true) {
            List<Comment> comments = eatComments();
            if (tok.kind == end || tok.kind == TypeKind.Eof) {
                break;
            }
            MethodParam param = readParam(constructor);
            param.beforeComments = comments;
            params.add(param);
            if (tok.kind == TypeKind.Comma) {
                next();
            } else {
                break;
            }
        }
        check(end);
        return params;
    }

    MethodParam readParam(Boolean constructor) {
        TypeToken start = tok;
        List<Annotation> annotations = readAnnotations();
        String name = null;
        MethodParams fparams = null;
        Expression def = null;
        DataType type = null;
        Boolean required = false;
        Boolean covariant = false;
        Boolean isFinal = false;
        if (isKey(this.tok, 'required')) {
            next();
            required = true;
        }
        if (isKey(this.tok, 'covariant')) {
            next();
            covariant = true;
        }
        if (isKey(this.tok, 'final')) {
            next();
            isFinal = true;
        }
        if(!constructor || !(isKey(this.tok, 'this') || isKey(this.tok, 'super'))) {
            type = readType(true);
        }
        Boolean hasThis = false;
        if (constructor && isKey(this.tok, 'this')) {
            hasThis = true;
            next();
            check(TypeKind.Dot);
        }
        Boolean hasSuper = false;
        if (constructor && isKey(this.tok, 'super')) {
            hasSuper = true;
            next();
            check(TypeKind.Dot);
        }
        eatComments();
        if (tok.kind == TypeKind.Name) {   
            name = checkName();
            if(this.tok.kind == TypeKind.Lpar || isType()) {
                type = readFunctionType(type);
            }
        }
        
        if (this.tok.kind == TypeKind.Assign
            || tok.kind == TypeKind.Colon) {
            next();
            def = expr(0);
        }
        return MethodParam(
            thisToken: hasThis ? 'this': hasSuper ? 'super' : null,
            name: name,
            dataType: type,
            required: required,
            annotations: annotations,
            defaultValue: def,
        );
    }
    FunctionType readFunctionType (DataType type) {
        List<DataType> args = [];
        if (isType()) {
            args = readTypeArgs();
        }
        MethodParams params = null;
        if(tok.kind == TypeKind.Lpar) {
            params = readMethodParams(false);
        }
        FunctionType fnType = FunctionType(
            params: params,
            typeArgs: args,
            returnType: type
        );
        if (this.tok.kind == TypeKind.Question) {
            fnType.optional = true;
            next();
        }
        return fnType;
    }

    ClassDecl readClass(List<Annotation> annotations, TypeToken start) {
        Boolean isAbstract = false;
        if (isKey(tok, 'abstract')) {
            isAbstract = true;
            next();
        }
        Boolean isMixin = false;
        Boolean isExtension = false;
        if (isKey(tok, 'mixin')) {
            isMixin = true;
            next();
        } else if (isKey(this.tok, 'extension')) {
            isExtension = true;
            next();
        } else {
            checkKey('class');
        }
        String name = checkName();
        ClassDecl cls = ClassDecl(isMixin, name);
        cls.isAbstract = isAbstract;
        if (tok.kind == TypeKind.Lt) {
            cls.generics = readTypeParams();
        }
        Boolean isMixinApplication = false;
        if(!isMixin && tok.kind == TypeKind.Assign) {
            isMixinApplication = true;
            next();
            cls.mixinApplicationType = readType(false);
        } else {
            if (!isExtension && !isMixin && isKey(tok, 'extends')) {
                next();
                cls.extendType = readType(false);
            }
            if ((isExtension || isMixin)  && isKey(this.tok, 'on')) {
                next();
                while (true) {
                    cls.ons.add(readType(false));
                    if (this.tok.kind != TypeKind.Comma) {
                        break;
                    }
                    next();
                }
            }
        }
        if (!isExtension && isKey(this.tok, 'with')) {
            next();
            while (true) {
                cls.mixins.add(readType(false));
                if (this.tok.kind != TypeKind.Comma) {
                    break;
                }
                next();
            }
        }
        cls.impls.clear();
        if (!isExtension && isKey(tok, 'implements')) {
            next();
            while (true) {
                cls.impls.add(readType(false));
                if (tok.kind != TypeKind.Comma) {
                    break;
                }
                next();
            }
        }
        if(!isMixinApplication && this.tok.kind == TypeKind.Lcbr) {
            check(TypeKind.Lcbr);
            cls.members.clear();
            while (true) {
                List<Comment> comments = eatComments();
                if (tok.kind == TypeKind.Rcbr || tok.kind == TypeKind.Eof) {
                    break;
                }
                ClassMember member = readClassMember(cls.name);
                member.comments = comments;
                cls.members.add(member);
            }
            check(TypeKind.Rcbr);
        } else {
            check(TypeKind.Semicolon);
        }
        cls.annotations = annotations;
        return cls;
    }

    ClassMember readClassMember(String className) {
        List<Comment> comments = eatComments();
        TypeToken start = tok;
        List<Annotation> annotations = readAnnotations();
        comments.addAll(eatComments());
        Boolean isStatic = false;
        Boolean isFinal = false;
        Boolean isConst = false;
        Boolean isFactory = false;
        Boolean isAbstract = false;
        Boolean isLate = false;
        Boolean isExternal = false;
        ASyncType asyncType = ASyncType.NONE;
        if (isKey(this.tok, 'external')) {
            isExternal = true;
            next();
        }
        if (isKey(tok, 'static')) {
            isStatic = true;
            next();
        }
        if (isKey(tok, 'late')) {
            isLate = true;
            next();
        }
        if (isKey(tok, 'final')) {
            isFinal = true;
            next();
        }
        if (isKey(tok, 'const')) {
            isConst = true;
            next();
        }
        if (isKey(tok, 'factory')) {
            isFactory = true;
            next();
        }
        if (isKey(tok, 'abstract')) {
            isAbstract = true;
            next();
        }
        DataType type = null;
        Boolean isConstructor = (tok.lit == className)
            && (peekTok.kind == TypeKind.Lpar
                || peekTok.kind == TypeKind.Dot);
        if(!isFactory && !isConstructor) {
            if((isConst || isFinal) && peekTok.kind == TypeKind.Assign) {
            } else {
                if (isKey(tok, 'Function')) {
                    type = readType(true); 
                } else if(!isKey(tok, 'operator') && (peekTok.kind != TypeKind.Lpar) 
                    && (tok.kind == TypeKind.Name && 
                        (peekTok.kind == TypeKind.Dot || isTypeName(tok.lit)))) {
                    type = readType(false);
                }
            }
        }
        eatComments();
        String name = checkName();

        if(tok.kind == TypeKind.Semicolon || tok.kind == TypeKind.Assign) {
            Expression init = null;
            if(tok.kind == TypeKind.Assign) {
                next();
                init = expr(0);
            }
            check(TypeKind.Semicolon);
            return FieldDecl(
                name: name,
                type: type,
                final: isFinal,
                static: isStatic,
                const: isConst,
                external: isExternal,
                value: init,
                annotations: annotations,
                comments: comments,
            );
        } 
        // Method Decal
        Boolean isSet = false;
        Boolean isGet = false;
        Block body = null;
        Block init = null;
        Expression exp = null;
        DataType alternate = null;
        if(isFactory || (isConstructor && tok.kind == TypeKind.Dot)) {
            if(name != className){
                error('Factory method should have same class name');
            }
            if(tok.kind == TypeKind.Dot) {
                check(TypeKind.Dot);
                name = checkName();
            }
        } else {
            if (name == 'set' && tok.kind == TypeKind.Name) {
                isSet = true;
                name = checkName();
            } else if (name == 'get' && tok.kind == TypeKind.Name) {
                isGet = true;
                name = checkName();
            }
        }
        if(name.equals('operator')) {
            name = tok.lit;
            next();
            while(this.tok.kind != TypeKind.Lpar) {
                name += tok.lit;
                next();
            }
        }
        TypeParams typeParams = null;
        if (tok.kind == TypeKind.Lt) {
            typeParams = readTypeParams();
        }
        MethodParams params = null;
        if (!isGet) {
            params = readMethodParams(isConstructor);
        }
        eatComments();
        if (tok.kind == TypeKind.Colon) {
            next();
            init = Block();
            Statement stmt = readStatement(
                skipSemiColon: true
            );
            init.statements.add(stmt);
            while(tok.kind == TypeKind.Comma) {
                next();
                stmt = readStatement(
                    skipSemiColon: true
                );
                init.statements.add(stmt);
            } 
        } else if (this.tok.kind == TypeKind.Assign) {
            next();
            alternate = readType(false);
            if(this.tok.kind == TypeKind.Dot) {
                next();
                String alFac = checkName();
            }
        } else {
            asyncType = readAsyncType();
        }
        String nativeString = null;
        if(isKey(tok, 'native' )) 
        {
            next();
            nativeString = stringExpr().value;
        }
        if (tok.kind == TypeKind.Lcbr) {
            body = readBlock(true);
        } else if (tok.kind == TypeKind.Arrow) {
            next();
            exp = expr(0);
            check(TypeKind.Semicolon);
        } else {
            check(TypeKind.Semicolon);
        }
        MethodDecl decl = MethodDecl(
            name: name,
            final: isFinal,
            static: isStatic,
            const: isConst,
            external: isExternal,
            setter: isSet,
            getter: isGet,
            factory: isFactory,
            params: params,
            init: init,
            returnType: type,
            generics: typeParams,
            body: body,
            annotations: annotations,
            asyncType: asyncType,
            exp: exp,
        );
        decl.nativeString = nativeString;
        return decl;
    }
    Boolean isTypeName(String name) {
	    return name != null && (primitives.contains(name) || ParserUtil.isTypeName(name));
    }

    Boolean isFactoryDecl() {
        return (tok.kind == TypeKind.Name && peekTok.kind == TypeKind.Dot) || (tok.kind == TypeKind.Name && (peekTok.kind == TypeKind.Lt || peekTok.kind == TypeKind.Lpar));
    }

    List<String> readPath() {
        check(TypeKind.At);
        List<String> list = [];
        while (true) {
            String name = checkName();
            list.add(name);
            if (tok.kind != TypeKind.Dot) {
                break;
            }
            next();
        }
        return list;
    }

    Block readBlock(Boolean withBraces) {
        Block block = Block();
        if (withBraces) {
            check(TypeKind.Lcbr);
            // check() already calls next once.
            // next();
            
        }
        while (true) {
            List<Comment> comments = eatComments();
            if (tok.kind == TypeKind.Rcbr || tok.kind == TypeKind.Eof) {
                block.afterComments = comments;
                break;
            }
            Statement smt = readStatement(
                comments: comments,
            );
            if (smt == null) {
                block.afterComments = comments;
                break;
            }
            block.statements.add(smt);
        }
        if (withBraces) {
            check(TypeKind.Rcbr);
            // check() already calls next once.
            // next();
            
        }
        return block;
    }

    Statement readStatement({Boolean skipSemiColon = false, List<Comment> comments}) {
        comments = comments != null ? comments : eatComments();
        Statement smt = null;
        TypeToken start = tok;
        List<Annotation> annotations = readAnnotations();
        if(tok.kind == TypeKind.Name && peekTok.kind == TypeKind.Colon) {
            String name = checkName();
            next();
            return LabelStatement(name);
        }
        if (isKey(tok, 'return')) {
            smt = readReturn();
        } else if (isKey(this.tok, 'yield')) {
          smt = YieldExpression(expr(0));
        } else if (isKey(this.tok, 'await')) {
            smt = AwaitExpression(expr(0));
            if (!skipSemiColon) {
                check(TypeKind.Semicolon);
            }
        } else if (isKey(this.tok, 'rethrow')) {
            next();
            smt = RethrowStatement();
            check(TypeKind.Semicolon);
        } else if (isKey(tok, 'throw')) {
            smt = readThrow(false);
        } else if (isKey(tok, 'for')) {
            smt = readFor(false);
        } else if (isKey(tok, 'while')) {
            smt = readWhile();
        } else if (isKey(tok, 'do')) {
            smt = readDoWhile();
        } else if (isKey(tok, 'switch')) {
            smt = readSwitch();
        } else if (isKey(tok, 'if')) {
            smt = readIf();
        } else if (isKey(tok, 'try')) {
            smt = readTry();
        } else if (isKey(this.tok, 'final') 
    		|| isKey(this.tok, 'late')) {
            smt = readDecl();
            if (!skipSemiColon) {
                check(TypeKind.Semicolon);
            }
        } else if (isKey(tok, 'break')) {
            next();
            String name = null;
            if(tok.kind == TypeKind.Name) {
                name = checkName();
            }
            check(TypeKind.Semicolon);
            smt = Break(name);
        } else if (isKey(tok, 'continue')) {
            next();
            String label = null;
            if(tok.kind == TypeKind.Name) {
                label = checkName();
            }
            check(TypeKind.Semicolon);
            smt = Continue(label);
        } else if (tok.kind == TypeKind.Lcbr) {
            smt = readBlock(true);
        } else {
            save();
            smt = readDecl();
            if (smt != null) {
                drop();
            } else {
                restore();
                // must be assignment or method call
                Boolean isPrefix = TypeToken.isPrefix(this.tok.kind);
                Expression exp = expr(1);
                if (TypeToken.isAssign(tok.kind)) {
                    // Assignment
                    smt = readAssignment(exp);
                } else if(exp == null) {
                    error('Unknown expression/statement');
                } else {
                    smt = exp as Statement;
                }
            }
            if (!skipSemiColon && !(smt is InlineMethodStatement)) {
                // We'll need to ignore the semi-colon after the "reset" part of a traditional for loop. No one writes a semi-colon there.
                check(TypeKind.Semicolon);
            }
        }
        smt.comments = comments;
        return smt;
    }

    Assignment readAssignment(Expression left) {
        TypeToken opt = tok;
        String op = tok.lit;
        next();
        Expression val = expr(0);
        return Assignment(
            op: op,
            left: left,
            right: val,
        );
    }

    Statement readDecl() {
        TypeToken start = this.tok;
        Boolean isFinal = false;
        Boolean isLate = false;
        Boolean isConst = false;
        if (isKey(this.tok, 'new')) {
            return null;
        }
        while(isKey(this.tok, 'final')
    		||isKey(this.tok, 'late')
    		||isKey(this.tok, 'const')) {
            if(isKey(tok, 'final')) {
                next();
                isFinal = true;
            }
            if(isKey(tok, 'late')) {
                next();
                isLate = true;
            }
            if(isKey(tok, 'const')) {
                next();
                isConst = true;
            }
        }
        DataType type = null;
        if(isFinal && this.peekTok.kind == TypeKind.Assign) {
            // No type
        } else {
            type = readType(false);
            if (type == null || this.tok.kind != TypeKind.Name) {
                return null;
            }
            if(type is ValueType && !isTypeName(type.name)) {
                return null;
            }
        }
        List<NameAndValue> names = [];
        String name = checkName();
        if(isType() || this.tok.kind == TypeKind.Lpar) {
            // May be inline function
            TypeParams typeParams = null;
            if(isType()) {
                typeParams = readTypeParams();
                if(typeParams == null) {
                    return null;
                }
            }
            MethodParams params = readMethodParams(false);
            Block block = null;
            Expression exp = null;
            if(this.tok.kind == TypeKind.Lcbr) {
                block = readBlock(true);
            } else {
                check(TypeKind.Arrow);
                exp = expr(0);
                check(TypeKind.Semicolon);
            }
            MethodDecl method = MethodDecl(
                body: block,
                exp: exp,
                generics: typeParams,
                name: name,
                params: params,
                returnType: type
            );
            return InlineMethodStatement(method);
        }
        Expression value = null;
        while(this.tok.kind == TypeKind.Comma || tok.kind == TypeKind.Assign) {
            if(tok.kind == TypeKind.Comma) {
                next();
                names.add(NameAndValue(name, value));
                name = checkName();
            } else {
                next();
                value = expr(0);
            }
        }
        names.add(NameAndValue(name, value));
        return Declaration(
            type: type,
            names: names,
            isFinal: isFinal,
            isLate: isLate,
            isConst: isConst,
        );
    }

    Boolean isDeclaration() {
        //Check if it simple declation i.e Integer a; or Integer b = __;
        Boolean simpleD = (tok.kind == TypeKind.Name && peekTok.kind == TypeKind.Name && (peekTok2.kind == TypeKind.Semicolon || peekTok2.kind == TypeKind.Assign));
        Boolean isType = tok.kind == TypeKind.Name && peekTok.kind == TypeKind.Lt && peekTok2.kind == TypeKind.Name && (peekTok3.kind == TypeKind.Gt || peekTok3.kind == TypeKind.Comma || peekTok3.kind == TypeKind.Lt);
        return simpleD || isType;
    }

    Statement readDoWhile() {
        TypeToken start = this.tok;
        next();
        // Skip over "do"
        Block block = readBlock(true);
        next();
        // Skip over "while"
        check(TypeKind.Lpar);
        Expression test = expr(0);
        check(TypeKind.Rpar);
        check(TypeKind.Semicolon);
        return DoWhileLoop(
            body: block,
            test: test,
        );
    }

    Statement readTry() {
        TypeToken start = this.tok;
        next();
        TryCatcheStatment tcs = TryCatcheStatment();
        tcs.body = readBlock(true);
        Block finallyBlock = null;
        while (isKey(tok, 'on') || isKey(tok, 'catch')) {
            //read catche
            TypeToken startC = this.tok;
            CatchPart catchPart = CatchPart();
            if (isKey(tok, 'on')) {
                next();
                catchPart.onType = readType(false);
            }
            if(isKey(tok, 'catch')) {
                checkKey('catch');
                check(TypeKind.Lpar);
                String name = checkName();
                String asName = null;
                if (tok.kind == TypeKind.Comma) {
                    next();
                    asName = checkName();
                }
                check(TypeKind.Rpar);
                catchPart.exp = name;
                catchPart.stackTrace = asName;
            }
            catchPart.body = readBlock(true);
            tcs.catchParts.add(catchPart);
        }
        if (isKey(tok, 'finally')) {
            next();
            tcs.finallyBody = readBlock(true);
        }
        return tcs;
    }

    Statement readIf() {
        TypeToken start = this.tok;
        next();
        check(TypeKind.Lpar);
        Expression test = expr(0);
        check(TypeKind.Rpar);
        Statement thenVal = readStatement();
        eatComments();
        Statement elseS = null;
        if (isKey(tok, 'else')) {
            next();
            elseS = readStatement();
        }
        return IfStatement(
            test: test,
            thenStatement: thenVal,
            elseStatement: elseS,
        );
    }

    Statement readSwitch() {
        TypeToken start = this.tok;
        next();
        check(TypeKind.Lpar);
        Expression test = expr(0);
        SwitchStatement ss = SwitchStatement(
            test: test,
        );
        check(TypeKind.Rpar);
        check(TypeKind.Lcbr);
        String label = null;
        while (tok.kind != TypeKind.Rcbr) {
            List<Comment> comments = eatComments();
            if (isKey(tok, 'case')) {
                next();
                SwitchCaseBlock caseBlock = SwitchCaseBlock();
                caseBlock.tests.add(expr(0));
                // while(true) {
                //     if(tok.kind != TypeKind.Comma) {
                //         break;
                //     }
                // }
                check(TypeKind.Colon);
                while (isKey(this.tok, 'case')) {
                    next();
                    caseBlock.tests.add(expr(0));
                    check(TypeKind.Colon);
                }
                if(label != null) {
                    caseBlock.label = label;
                    label = null;
                }
                while (true) {
                    List<Comment> comments2 = eatComments();
                    if (tok.kind == TypeKind.Rcbr || isKey(tok, 'case') || isKey(tok, 'default')) {
                        break;
                    }
                    if (this.tok.kind == TypeKind.Name
                        && this.peekTok.kind == TypeKind.Colon) {
                        break;
                    }
                    Statement smt = readStatement(
                        comments: comments2,
                    );
                    if (smt == null) {
                        break;
                    }
                    caseBlock.statements.add(smt);
                }
                ss.cases.add(caseBlock);
            } else if (isKey(this.tok, 'default')) {
                next();
                check(TypeKind.Colon);
                while (tok.kind != TypeKind.Rcbr) {
                    List<Comment> comments2 = eatComments();
                    ss.defaults.add(readStatement(comments: comments2));
                }
                break;
            } else if (this.tok.kind == TypeKind.Name
              && this.peekTok.kind == TypeKind.Colon) {
                label = checkName();
                next();
            } else {
                break;
            }
        }
        check(TypeKind.Rcbr);
        return ss;
    }

    Boolean isKey(TypeToken token, String key) {
        return token.kind == TypeKind.Name && token.lit == key;
    }

    Statement readWhile() {
        TypeToken start = this.tok;
        next();
        check(TypeKind.Lpar);
        Expression test = expr(0);
        check(TypeKind.Rpar);
        Statement stmt = null;
        if(this.tok.kind == TypeKind.Lcbr) {
            stmt = readBlock(true);
        } else {
            stmt = readStatement();
        }

        return WhileLoop(
            body: stmt,
            test: test,
        );
    }

    ForEachLoop readForEachLoop(Boolean forCollection) {
        DataType type = null;
        if(!isKey(peekTok, 'in')) {
            type = readType(false);
            if (type == null) {
                return null;
            }
        }
        if(tok.kind != TypeKind.Name) {
            return null;
        }
        String name = checkName();
        if(!isKey(tok, 'in')) {
            return null;
        }
        next();
        Expression exp = expr(0);
        if(tok.kind != TypeKind.Rpar) {
            return null;
        }
        next();
        Expression block = null;
        if(!forCollection) {
            block = readStatement();
        }
        return ForEachLoop(
            body: block,
            collection: exp,
            dataType: type,
            name: name
        );
    }

    Statement readFor(Boolean forCollection) {
        TypeToken start = this.tok;
        next();
        check(TypeKind.Lpar);
        Boolean isFinal = false;
        if(isKey(tok, 'final')) {
            next();
            isFinal = true;
        }
        save();
        ForEachLoop loop = readForEachLoop(forCollection);
        if (loop != null) {
            drop();
            return loop;
        } else {
            restore();
            // Normal for loop
            List<Statement> inits = [];
            // Need to check prevTok also here since semi-colon is check()-ed while reading statement.
            // TODO: Check if this also happens for EOF
            while (true) {
                if (tok.kind == TypeKind.Semicolon || tok.kind == TypeKind.Eof) {
                    next();
                    break;
                }
                inits.add(readStatement());
                if (tok.kind != TypeKind.Comma) {
                    break;
                }
                next();
            }
            Declaration decl = null;
            if ((inits.length > 0) && (inits.get(0) is Declaration)) {
                decl = inits.removeAt(0) as Declaration;
            }
            Expression exp = null;
            if(this.tok.kind != TypeKind.Semicolon) {
                exp = expr(0);    	  
            }
            next();
            // Skip over the semi-colon
            List<Statement> resets = [];
            while (true) {
                if (tok.kind == TypeKind.Rpar || tok.kind == TypeKind.Eof) {
                    break;
                }
                resets.add(readStatement(
                    skipSemiColon: true,
                ));
                if (tok.kind != TypeKind.Comma) {
                    break;
                }
                next();
            }
            check(TypeKind.Rpar);
            Expression block = null;
            if (!forCollection) {
                block = readStatement();
            }
            return ForLoop(
                body: block,
                decl: decl,
                test: exp,
                inits: inits,
                resets: resets,
            );
        }
    }

    ThrowStatement readThrow(Boolean asExp) {
        TypeToken start = this.tok;
        next();
        ThrowStatement ret = ThrowStatement();
        ret.exp = expr(0);
        if(!asExp) {
            check(TypeKind.Semicolon);
        }
        return ret;
    }

    Return readReturn() {
        TypeToken start = this.tok;
        next();
        Return ret = Return();
        if (tok.kind != TypeKind.Semicolon) {
            ret.expression = expr(0);
        }
        check(TypeKind.Semicolon);
        return ret;
    }

    Expression expr(Integer precedence) {
        List<Comment> comments = eatComments();
        Expression node = null;
        TypeToken start = this.tok;
        switch (tok.kind) {
            case TypeKind.Name:
                {
                    if (isKey(tok, 'true') || isKey(tok, 'false')) {
                        node = LiteralExpression(
                            type: LiteralType.TypeBoolean,
                            value: tok.lit,
                        );
                        next();
                    } else if (isKey(tok, 'null')) {
                        node = NullExpression();
                        next();
                    } else if (peekTok.kind == TypeKind.Arrow) {
                        return singleParamLambda();
                    } else if (isKey(tok, 'throw')) {
                        return readThrow(true);
                    } else if (isKey(tok, 'r')) {
                        node = stringExpr();
                    } else if (isKey(tok, 'new')) {
                        next();
                        return expr(precedence);
                    } else {
                        node = nameExpr();
                    }
                }

            case TypeKind.String:
                {
                    node = stringExpr();
                }

            case TypeKind.Minus:
                {
                    node = prefixExpr();
                }

            case TypeKind.Mul:
                {
                    node = prefixExpr();
                }

            case TypeKind.Not:
                {
                    node = prefixExpr();
                }

            case TypeKind.BitNot:
                {
                    node = prefixExpr();
                }

            case TypeKind.Number:
                {
                    node = parseNumberLiteral();
                }

            case TypeKind.Lpar:
                {
                    node = parOrLambdaExpr();
                }

            case TypeKind.Lsbr:
                {
                    ArrayExpression arr = arrayInit(ArrayType.List);
                    node = arr;
                }

            case TypeKind.Lcbr:
                {
                    ArrayExpression arr = arrayInit(ArrayType.Map);
                    node = arr;
                }

            case TypeKind.Lt:
                {
                    check(TypeKind.Lt);
                    DataType type = readType(false);
                    if(tok.kind == TypeKind.Gt) {
                        check(TypeKind.Gt);
                        Boolean isSet = tok.kind == TypeKind.Lcbr;
                        ArrayExpression arr = arrayInit(isSet? ArrayType.Set : ArrayType.List);
                        arr.enforceType = type;
                        node = arr;
                    } else {
                        check(TypeKind.Comma);
                        DataType valueType = readType(false);
                        check(TypeKind.Gt);
                        ArrayExpression arr = arrayInit(ArrayType.Map);
                        arr.enforceType = type;
                        arr.valueType = valueType;
                        node = arr;
                    }
                }

            case TypeKind.Inc:
            case TypeKind.Dec:
                {
                    String prefix = this.tok.lit;
                    next();
                    Expression exp = expr(precedence);
                    node = PrefixExpression(
                        prefix: prefix,
                        on: exp,
                    );
                }

            default: 
                {
                    error('bad token: ' + tok.kind.toString());
                }

        }
        eatComments();
        while (precedence < tok.precedence) {
            if (tok.kind == TypeKind.Dot) {
                node = dotExpr(node, false, false);
            } else if (this.tok.kind == TypeKind.DotDot) {
                node = dotDotExpr(node, false, false);
            } else if (this.tok.kind == TypeKind.Lpar) {
                node = fnCallExp(node);
            } else if (tok.kind == TypeKind.Lsbr) {
                node = indexExpr(node);
            } else if (isKey(tok, 'as')) {
                next();
                DataType type = readType(false);
                node = TypeCastOrCheckExpression(
                    check: false,
                    dataType: type,
                    exp: node,
                );
            } else if (isKey(tok, 'is')) {
                next();
                Boolean isNot = false;
                if(tok.kind == TypeKind.Not) {
                    isNot = true;
                    next();
                }
                DataType type = readType(false);
                node = TypeCastOrCheckExpression(
                    check: true,
                    dataType: type,
                    exp: node,
                    isNot: isNot,
                );
            } else if (tok.kind == TypeKind.LeftShift) {
                TypeToken ttok = tok;
                next();
                Expression right = expr(precedence - 1);
                if(ttok.kind == TypeKind.Assign) {
                    node = Assignment(
                        left: node,
                        right: right,
                        op: ttok.lit,
                    );
                } else {
                    node = BinaryExpression(
                        op: ttok.lit,
                        left: node,
                        right: right,
                    );
                }
            } else if (TypeToken.isInfix(tok.kind)) {
                node = infixExpr(node);
            } else if (this.tok.kind == TypeKind.Inc 
                || this.tok.kind == TypeKind.Dec 
                || this.tok.kind == TypeKind.Not) {
                if(this.tok.kind == TypeKind.Not 
                    && this.peekTok.kind == TypeKind.Lt
    			    && isBeside(tok, peekTok)) {
                    next();
                    List<DataType> typeArgs = readTypeArgs();
                    MethodCall call = callExpr(null, typeArgs: typeArgs);
                    call.notNull = true;
                    call.on = node;
                } else {
                    node = PostfixExpression(
                        postfix: tok.lit,
                        on: node,
                    );
                    next();
                }
            } else if (this.tok.kind == TypeKind.Question) {
                next();
                if (tok.kind == Dot){
                    node = dotExpr(node, true, false);
                } else if (this.tok.kind == TypeKind.DotDot) {
                    node = dotDotExpr(node, true, false);
                } else if (this.tok.kind == TypeKind.Lsbr) {
                    node = indexExpr(node, checkNull:true);
                } else {
                    return ternaryExpr(node);
                }
            } else if (this.tok.kind == TypeKind.Not) {
                next();
                if (tok.kind == Dot){
                    node = dotExpr(node, false, true);
                } else {
                    error('Not sure what should happen here');
                }
            } else {
                return node;
            }
            if(tok.kind == TypeKind.CommentSingle || tok.kind == TypeKind.CommentMulti) {
                node.comments.addAll(eatComments());
            }
        }
        if (node != null) {
            node.comments = comments;
        }
        return node;
    }

    Boolean isType() {
        return tok.kind == TypeKind.Lt;
    }

    Expression parOrLambdaExpr() {
        TypeToken start = this.tok;
        if(tok.kind == TypeKind.Lpar && peekTok.kind == TypeKind.Rpar) {
            next();
            return lambdaExp();
        }
        check(TypeKind.Lpar);
        save();
        Expression exp = null;
        if (this.tok.kind != TypeKind.Rpar) {
            exp = lambdaExp();
        }
        if (exp == null) {
            restore();
            exp = expr(0);
            check(TypeKind.Rpar);
            return ParExpression(
                exp: exp,
            );
        } else {
            drop();
            return exp;
        }
    }

    Expression lambdaExp() {
        TypeToken start = tok;
        List<Param> params = [];
        while (tok.kind != TypeKind.Rpar) {
            if(tok.lit.equals('_')) {
                next();
                continue;
            }
            if((peekTok.kind == TypeKind.Rpar ||
    		  peekTok.kind == TypeKind.Comma)) {
                // Name without type
                if(tok.kind != TypeKind.Name) {
                    return null;
                }
                String name = checkName();
                params.add(Param(
                    name: name,
                ));
            } else {
                DataType type = readType(false);
                if(tok.kind != TypeKind.Name) {
                    return null;
                }
                String name = checkName();
                params.add(Param(
                    name: name,
                    type: type
                ));
            }
            if (tok.kind == TypeKind.Comma) {
                next();
            } else {
                break;
            }
        }
        if(tok.kind != TypeKind.Rpar) {
            return null;
        }
        next();
        LambdaExpression exp = LambdaExpression(
            params: params,
        );
        exp.asyncType = readAsyncType();
        if (this.tok.kind == TypeKind.Arrow) {
            next();
            Expression val = expr(1);
            if (TypeToken.isAssign(this.tok.kind)) {
                // Added because Assignment is only being read as part of a statement.
                val = readAssignment(val);
            }
            exp.expression = val;
        } else if (this.tok.kind == TypeKind.Lcbr) {
            exp.body = readBlock(true);
        } else {
            return null;
        }
        return exp;
    }

    ASyncType readAsyncType() {
        if (isKey(tok, 'async')) {
            next();
            if(tok.kind == TypeKind.Mul) {
                next();
                return ASyncType.ASYNCP;
            }
            return ASyncType.ASYNC;
        }
        if (isKey(tok, 'sync')) {
            next();
            next();
            return ASyncType.SYNCP;
        }
        return ASyncType.NONE;
    }

    Expression singleParamLambda() {
        TypeToken start = tok;
        String name = checkName();
        check(TypeKind.Arrow);
        List<Param> params = [
            Param(
                name: name,
            ),
        ];
        LambdaExpression exp = LambdaExpression(
            params: params,
        );
        exp.expression = expr(0);
        return exp;
    }

    Expression ternaryExpr(Expression condition) {
        Expression yes = expr(0);
        if(tok.kind != TypeKind.Colon) {
            return null;
        } else {
            next();
        }
        Expression no = expr(0);
        TerinaryExpression exp = TerinaryExpression(
            condition: condition,
            ifTrue: yes,
            ifFalse: no,
        );
        return exp;
    }

    Expression switchExpr() {
        TypeToken start = this.tok;
        checkKey('switch');
        check(TypeKind.Lpar);
        Expression test = expr(0);
        SwitchExpression exp = SwitchExpression(
            on: test,
        );
        check(TypeKind.Rpar);
        check(TypeKind.Lcbr);
        while (tok.kind != TypeKind.Rcbr) {
            if (isKey(tok, 'case')) {
                next();
                CaseExpression caseExp = CaseExpression();
                while (true) {
                    caseExp.tests.add(expr(0));
                    if (tok.kind != TypeKind.Comma) {
                        break;
                    }
                }
                check(TypeKind.Colon);
                caseExp.result = expr(0);
                exp.cases.add(caseExp);
            } else if (isKey(tok, 'default')) {
                next();
                check(TypeKind.Colon);
                exp.onElse = expr(0);
                break;
            } else {
                break;
            }
        }
        check(TypeKind.Rcbr);
        return exp;
    }

    Expression infixExpr(Expression left) {
        TypeToken ttok = tok;
        TypeKind op = tok.kind;
        String lit = ttok.lit;
        Integer precedence = tok.precedence;
        next();
        if(prevTok.kind == TypeKind.Gt && tok.kind == TypeKind.Gt) {
            next();
            precedence = TypeToken.preShift;
            lit = '>>';
        }
        if (isKey(ttok, 'as') || isKey(ttok, 'is')) {
            expectingType = true;
        }
        Expression right = expr(precedence);
        if(ttok.kind == TypeKind.Assign) {
            return Assignment(
                left: left,
                right: right,
                op: ttok.lit,
            );
        }
        return BinaryExpression(
            op: lit,
            left: left,
            right: right,
        );
    }
    
    DataType readValueType(Boolean acceptFnWithNoRet){
        if(this.tok.kind != TypeKind.Name) {
            return null;
        }
        String name = checkName();
        String package = null;
        if(tok.kind == TypeKind.Dot) {
            next();
            package = name;
            name = checkName();
        }
        ValueType type = ValueType(name);
        type.in = package;
        if (tok.kind == TypeKind.Lt) {
            List<DataType> typeArgs = readTypeArgs();
            if(typeArgs == null) {
                return null;
            }
            type.args = typeArgs;
        }
        DataType result = type;
        if(acceptFnWithNoRet && !isTypeName(name) && tok.kind == TypeKind.Lpar) {
            MethodParams params = readMethodParams(false);
            ValueType returnType = ValueType('void');
            FunctionType fnType = FunctionType(
                params: params, 
                returnType: returnType,
                typeArgs: type.args
            );
            result = fnType;
        }
        if (this.tok.kind == TypeKind.Question
                && isBeside(prevTok, tok)) {
            result.optional = true;
            next();
        }
        return type;
    }

    DefType readDefType() {
	    if (this.tok.kind != TypeKind.Name) {
	      return null;
	    }
	    String name = checkName();
	    String packageValue = null;
	    if (this.tok.kind == TypeKind.Dot) {
	      next();
	      packageValue = name;
	      name = checkName();
	    }
	    DefType type = DefType(name, false);
	    type.in = packageValue;
	    if (this.tok.kind == TypeKind.Lt) {
	      TypeParams params = readTypeParams();
	      if(params == null) {
	    	  return null;
	      }
	      type.params = params;
	    }
	    if (this.tok.kind == TypeKind.Question
	    		&& isBeside(prevTok, tok)) {
	      type.optional = true;
	      next();
	    }
	    return type;
    }
    Boolean isBeside(TypeToken first, TypeToken next) {
	    return first.pos + first.len == next.pos;
    }

    DataType readType(Boolean acceptFnWithNoRet) {
        if (isKey(this.tok, 'Function')) {
	      next();
	      return readFunctionType(null);
	    }
        DataType type = readValueType(acceptFnWithNoRet);
        if(type == null) {
            return null;
        }
        if(isKey(tok, 'Function')) {
            next();
            type = readFunctionType(type);
        }
        return type;
    }

    List<DataType> readTypeArgs() {
        TypeToken start = tok;
        check(TypeKind.Lt);
        List<DataType> args = [];
        while (true) {
            DataType sub = readType(false);
            if(sub == null) {
                return null;
            }
            args.add(sub);
            eatComments();
            if (this.tok.kind != TypeKind.Comma) {
                break;
            } else {
                next();
            }
        }
        if(tok.kind != TypeKind.Gt) {
            return null;
        }
        next();
        return args;
    }

    void error(String msg) {
        D3ELogger.error(msg);
        throw Exception(msg);
    }

    void readFirstToken() {
        next();
        next();
        next();
        next();
        next();
    }

    void next() {
        prevTok = tok;
        tok = peekTok;
        peekTok = peekTok2;
        peekTok2 = peekTok3;
        peekTok3 = peekTok4;
        peekTok4 = scanner.scan();
    }

    ArrayExpression arrayInit(ArrayType type) {
        ArrayExpression arrExp = ArrayExpression();
        arrExp.type = type;
        TypeKind start = type == List ? TypeKind.Lsbr : TypeKind.Lcbr;
        TypeKind end = type == List ? TypeKind.Rsbr : TypeKind.Rcbr;
        check(start);
        while (true) {
            List<Comment> comments = eatComments();
            if (tok.kind == end || tok.kind == TypeKind.Eof) {
                break;
            }
            ArrayItem item = arrayItem(arrExp, 
                comments: comments,
            );
            arrExp.values.add(item);
            List<Comment> comments2 = eatComments();
            item.afterComments = comments2;
            if (tok.kind != TypeKind.Comma) {
                break;
            } else {
                next();
            }
        }
        check(end);
        return arrExp;
    }

    ArrayItem arrayItem(ArrayExpression arrExp, {List<Comment> comments}) {
        comments.addAll(eatComments());
        TypeToken start = this.tok;
        switch (tok.kind) {
            case TypeKind.Ellipses:
                {
                    next();
                    Boolean checkNull = tok.kind == TypeKind.Question;
                    if(checkNull) {
                        next();
                    }
                    Expression exp = expr(0);
                    return CollectionSpread(
                        checkNull: checkNull,
                        values: exp,
                        beforeComments: comments,
                    );
                }

            default: 
                {
                    if (isKey(tok, 'if')) {
                        next();
                        check(TypeKind.Lpar);
                        Expression test = expr(0);
                        check(TypeKind.Rpar);
                        ArrayItem exp = arrayItem(arrExp);
                        ArrayItem elseS = null;
                        if (isKey(tok, 'else')) {
                            next();
                            elseS = arrayItem(arrExp);
                        }
                        CollectionIf cif = CollectionIf(
                            test: test,
                            thenItem: exp,
                            elseItem: elseS,
                        );
                        cif.beforeComments = comments;
                        return cif;
                    } else if (isKey(tok, 'for')) {
                        Statement stmt = readFor(true);
                        ArrayItem value = arrayItem(arrExp);
                        CollectionFor cFor =  CollectionFor(
                            value: value,
                            stmt: stmt,
                        );
                        cFor.beforeComments  = comments;
                        return cFor;
                    } else {
                        if(arrExp.type == ArrayType.Map) {
                            Expression key = expr(0);
                            if(tok.kind == TypeKind.Colon) {
                	            next();
                                Expression value = expr(0);
                                return MapItem(
                                    key:key,
                                    value: value,
                                    comments: comments
                                );
                            } else {
                                arrExp.type = ArrayType.Set;
                                ExpressionArrayItem item =  ExpressionArrayItem(
                                    exp: key,
                                );
                                item.beforeComments = comments;
                                return item;
                            }
                        } else {
                            Expression exp = expr(0);
                            ExpressionArrayItem item =  ExpressionArrayItem(
                                exp: exp,
                            );
                            item.beforeComments = comments;
                            return item;
                        }
                    }
                }

        }
    }

    void check(TypeKind expected) {
        if (tok.kind != expected) {
            if (tok.kind == TypeKind.Name) {
                error('unexpected name `' + tok.lit + '`, expecting ' + expected.toString());
            } else {
                error('unexpected name `' + tok.kind.toString() + '`, expecting ' + expected.toString());
            }
        }
        next();
    }

    Expression parseNumberLiteral() {
        String lit = tok.lit;
        Expression node;
        if (ParserUtil.isDouble(lit)) {
            node = LiteralExpression(
                type: LiteralType.TypeDouble,
                value: lit,
            );
        } else {
            node = LiteralExpression(
                type: LiteralType.TypeInteger,
                value: lit,
            );
        }
        next();
        return node;
    }

    Expression prefixExpr() {
        TypeToken ttok = tok;
        next();
        Expression right = (ttok.kind == TypeKind.Minus ? expr(TypeToken.preUnPrefix) : expr(TypeToken.preUnPrefix));
        return PrefixExpression(
            prefix: ttok.lit,
            on: right,
        );
    }

    Expression vweb() {
        return null;
    }

    LiteralExpression stringExpr() {
        TypeToken start = tok;
        Boolean isRaw = false;
        String value = '';
        do {
            isRaw = tok.kind == TypeKind.Name && tok.lit == 'r';
            if (isRaw) {
                next();
            }
            value = value + tok.lit;
            next();
            eatComments();
        } while (tok.kind == TypeKind.String || peekTok.lit == 'r');
        LiteralExpression node;
        if (tok.kind != TypeKind.Dollar) {
            node = LiteralExpression(
                type: LiteralType.TypeString,
                value: isRaw ? value: value,
                isRawString: isRaw,
            );
            return node;
        }
        // Handle string interpolation
        return null;
    }

    Expression nameExpr() {
        if (expectingType) {
            expectingType = false;
            DataType type = readType(false);
            //TODO
            
        }
        //Raw Strings
        if (tok.lit == 'r' && peekTok.kind == TypeKind.String && !insideStrInterp) {
            return stringExpr();
        }
        String name = checkName();
        if(name.equals('await')) {
            return AwaitExpression(expr(0));
        }
        if(name.equals('const')) {
            return ConstExpression(expr(0));
        }
        if(tok.kind == TypeKind.Lt) {
            save();
            List<DataType> args = readTypeArgs();
            if(args == null) {
                restore();
            } else {
                drop();
            }
            return callExpr(name, typeArgs: args);
        }
        if (this.tok.kind == TypeKind.Lpar) {
            return callExpr(name);
        }
        return FieldOrEnumExpression(
            name: name,
        );
    }

    MethodCall callExpr(String name, {List<DataType> typeArgs}) {
        TypeToken start = this.tok;
        if(this.tok.kind == TypeKind.Dot) {
            // Call on Type
            next();
            name = checkName();
        }
        if(tok.kind != TypeKind.Lpar) {
            return null;
        } else {
            next();
        }
        MethodCall mCall = MethodCall(
            name: name,
            typeArgs: typeArgs,
        );
        while (true) {
            List<Comment> comments = eatComments();
            if (tok.kind == TypeKind.Rpar || tok.kind == TypeKind.Eof || peekTok.kind == TypeKind.Colon) {
                break;
            }
            Argument arg = readArg();
            arg.arg.comments = comments;
            mCall.positionArgs.add(arg);
            if (tok.kind != TypeKind.Comma) {
                break;
            }
            check(TypeKind.Comma);
        }
        while (true) {
            List<Comment> comments2 = eatComments();
            if (tok.kind == TypeKind.Rpar || tok.kind == TypeKind.Eof || peekTok.kind != TypeKind.Colon) {
                break;
            }
            NamedArgument arg = readNamedArg();
            arg.beforeComments = comments2;
            mCall.namedArgs.add(arg);
            if (tok.kind != TypeKind.Comma) {
                break;
            }
            check(TypeKind.Comma);
        }
        check(TypeKind.Rpar);
        return mCall;
    }

    List<Comment> eatComments() {
        List<Comment> comments = [];
        while (tok.kind == TypeKind.CommentSingle || tok.kind == TypeKind.CommentMulti) {
            comments.add(comment());
        }
        return comments;
    }

    Comment comment() {
        TypeToken start = tok;
        String text = tok.lit;
        next();
        if (start.kind == TypeKind.CommentMulti) {
            text = trimLines(text, start.index - 1);
        }
        return Comment(text, start.kind == TypeKind.CommentMulti ? CommentType.MULTI : CommentType.SINGLE);
    }

    String trimLines(String text, Integer index) {
        List<String> lines = text.split('\n');
        lines = lines.map((l) {
            String line = l.trimLeft();
            Integer removed = l.length - line.length;
            Integer from = removed;
            if (index > 0) {
                removed = Math.minInt(index, from);
            }
            String res = l.substring(from);
            return res;
        }).toList();
        return lines.join('\n');
    }

    Expression indexExpr(Expression left, {Boolean checkNull, Boolean notNull}) {
        TypeToken start = this.tok;
        next();
        Expression idx = expr(0);
        check(TypeKind.Rsbr);
        return ArrayAccess(
            on: left,
            index: idx,
            checkNull: checkNull,
            notNull: notNull,
        );
    }
    Expression fnCallExp(Expression left) {
	    MethodCall call = callExpr(null);
	    return FnCallExpression(
            on: left, 
            call: call,
        );
    }

    Expression dotExpr(Expression left, Boolean checkNull, Boolean notNull) {
        TypeToken start = this.tok;
        next();
        String name = checkName();
        List<DataType> typeArgs = [];
        if(isType()) {
            save();
            typeArgs = readTypeArgs();
            if(typeArgs != null) {
                drop();
            } else {
                restore();
            }
        }
        if(tok.kind == TypeKind.Lpar) {
    	    MethodCall call = callExpr(name, typeArgs: typeArgs);
            call.on = left;
            call.checkNull = checkNull;
            call.notNull = notNull;
            return call;
        } 
        return FieldOrEnumExpression(
            on: left,
            name: name,
            checkNull: checkNull,
            notNull: notNull,
        );
        
    }
    Expression dotDotExpr(Expression left, Boolean checkNull, Boolean notNull) {
	    TypeToken start = this.tok;
	    CascadeExp exp = CascadeExp(left);
	    while (this.tok.kind == TypeKind.DotDot) {
            next();
            if(tok.kind == TypeKind.Name) {
                Expression sub = expr(0);
                if(sub is Statement) {
                    exp.calls.add(sub as Statement);
                } else {
                    error('This is not a valid statement');
                }
            } else {
                Expression index = indexExpr(null);
                Assignment assign = readAssignment(index);
                exp.calls.add(assign);
            }
        }
	    return exp;
	  }

    Argument readArg() {
        Expression exp = expr(0);
        List<Comment> comments2 = eatComments();
        return Argument(
            arg: exp,
            afterComments: comments2,
        );
    }

    NamedArgument readNamedArg() {
        TypeToken start = this.tok;
        String name = checkName();
        check(TypeKind.Colon);
        Expression value = expr(0);
        List<Comment> comments2 = eatComments();
        return NamedArgument(
            name: name,
            value: value,
            afterComments: comments2,
        );
    }

    String checkName() {
        String lit = tok.lit;
        check(TypeKind.Name);
        return lit;
    }

    void save() {
        TokenFrame frame = TokenFrame(
            tok: tok,
            peekTok: peekTok,
            peekTok2: peekTok2,
            peekTok3: peekTok3,
            peekTok4: peekTok4,
            prevTok: prevTok,
            pos: scanner.pos,
        );
        savedFrames.add(frame);
    }

    void restore() {
        if(savedFrames.isEmpty) {
            error('No saved frames found');
        }
        TokenFrame frame = savedFrames.removeLast();
        this.scanner.pos = frame.pos;
        this.tok = frame.tok;
        this.prevTok = frame.tok;
        this.peekTok = frame.peekTok;
        this.peekTok2 = frame.peekTok2;
        this.peekTok3 = frame.peekTok3;
        this.peekTok4 = frame.peekTok4;
    }

    void drop(){
        if(savedFrames.isEmpty) {
            error('No saved frames found');
        }
        savedFrames.removeLast();
    }

}