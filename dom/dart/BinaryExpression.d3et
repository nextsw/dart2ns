server class BinaryExpression extends Statement {
    String op;
    Expression left;
    Expression right;
    MethodDecl method;
    BinaryExpression({this.op, this.left, this.right});


    void resolve(ResolveContext context) {
        Map<String, String> typeChecks = Map();
        left.getTypeChecks(typeChecks);
        left.resolve(context);
        
        Boolean newScope = false;
        if(typeChecks.isNotEmpty && op == '&&') {
            // Create new scope if needed
            context.scope = Scope(parent: context.scope);
            typeChecks.forEach((k,v){
                context.scope.add(k, ValueType(v));
            });
            newScope = true;
        }
        right.resolve(context);
        if(newScope){
            context.scope = context.scope.parent;
        }
        resolvedType = switch(op) {
            case '??': context.commonType(left.resolvedType, right.resolvedType)
            default: left.resolvedType
        };
    }
    void collectUsedTypes(List<DataType> types) {
        left.collectUsedTypes(types);
        right.collectUsedTypes(types);
    }

    void simplify(Simplifier s) {
        if(op == '??=') {
            s.add(Assignment(
                op: op,
                left: left,
                right: right,
            ));
            s.markDelete();
        } else {
            left = s.makeSimple(left);
            right = s.makeSimple(right);
        }
    }
    void visit(ExpressionVisitor visitor) {
        visitor.visit(right);
        visitor.visit(left);
    }

    void getTypeChecks(Map<String, String> checks){
        if(op == '&&'){
            left.getTypeChecks(checks);
            right.getTypeChecks(checks);
        }
    }
}