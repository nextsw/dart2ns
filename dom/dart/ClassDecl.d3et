server class ClassDecl extends TopDecl {
    Boolean isAbstract;
    TypeParams generics;
    DataType extendType;
    List<DataType> impls = [];
    List<ClassMember> members = [];
    List<DataType> mixins = [];
    List<DataType> ons = [];
    Boolean isMixin;
    DataType mixinApplicationType;
    String _packagePath;
    Map<String, Map<String, DataType>> resolvedGenerics;

    ClassType type;
    ClassDecl(this.isMixin, String name) : super(name, TopDeclType.Class, '');

    void collectUsedTypes(){
        usedTypes.addAll(impls);
        if(extendType != null) {
            usedTypes.add(extendType);
        }
        for(ClassMember cm in members) {
            if(cm is FieldDecl) {
                FieldDecl fd = cm as FieldDecl;
                if(fd.type != null) {
                    usedTypes.add(fd.type);
                }
            } else if (cm is MethodDecl) {
                MethodDecl md = cm as MethodDecl;
                if(md.returnType != null) {
                    usedTypes.add(md.returnType);
                }
                for(MethodParam m in md.allParams) {
                    if(m.dataType != null) {
                        usedTypes.add(m.dataType);
                    }
                }
            }
        }
    }

    void resolveGenerics(ResolveContext context) {
        if(resolvedGenerics != null){
            return;
        }
        resolvedGenerics = Map();
        if(generics != null){
            Map<String, DataType> ourGenercis = Map();
            for(TypeParam p in generics.params) {
                if(p.extendType != null) {
                    ourGenercis.set(p.name, p.extendType);
                } else {
                    ourGenercis.set(p.name, ValueType(p.name));
                }
            }
            resolvedGenerics.set(name, ourGenercis);
        }
        // Check extends
        if(extendType != null) {
            resolveGenericsForType(context, extendType);
        }

        impls.forEach((i){
            resolveGenericsForType(context, i);
        });
        mixins.forEach((i){
            resolveGenericsForType(context, i);
        });
        D3ELogger.info('Resolved Generics for '+ name);
    }
    void resolveGenericsForType(ResolveContext context, DataType type) {
        if(type != null) {
            ClassDecl ex = lib.get(type.name) as ClassDecl;
            if(ex != null) {
                ex.resolveGenerics(context);
                ValueType extType = type as ValueType;
                Map<String, DataType> replaced = Map();
                for(Integer x=0; x< extType.args.length; x++){
                    DataType arg = extType.args.get(x);
                    TypeParam param = ex.generics.params.get(x);
                    replaced.set(param.name, arg);
                }
                addResolvedGenerics(ex.resolvedGenerics, replaced);
            } else {
                context.error('Unable to find Type: '+ type.name);
            }
        }
    }
    void addResolvedGenerics(Map<String, Map<String, DataType>> from, Map<String, DataType> replaced) {
        from.forEach((k, v){
            Map<String, DataType> temp = Map();
            v.forEach((k1, v1) {
                DataType r = replaced.get(k1) ?? v1;
                temp.set(k1, r);
            });
            resolvedGenerics.set(k, temp);
        });
    }

    void resolveFields(ResolveContext context){
        for(ClassMember cm in members){
            cm.cls = this;
        }
        resolveGenerics(context);
        // D3ELogger.info('Resolving Class: ' + name);
        context.instanceClass = this;
        context.scope = Scope(parent: context.scope);
        for(ClassMember cm in members.where(m => m is FieldDecl)){
            (cm as FieldDecl).resolve(context);
        }
        context.scope = context.scope.parent;
        context.instanceClass = null;
    }
    void resolveMethods(ResolveContext context){
        // D3ELogger.info('Resolving Class: ' + name);
        context.instanceClass = this;
        context.scope = Scope(parent: context.scope);
        for(ClassMember cm in members.where(m => m is MethodDecl)){
            (cm as MethodDecl).resolve(context);
        }
        context.scope = context.scope.parent;
        context.instanceClass = null;
    }

    void simplify(Simplifier s){
        for(ClassMember cm in members){
            cm.simplify(s);
        }
    }

    String get packagePath {
        if(_packagePath != null){
            return _packagePath;
        }
        String outPath = lib.packagePath;
        List<String> split = outPath.split('/');
        split.removeLast();
        split.add(name);
        _packagePath = split.join('/');
        return _packagePath;
    }

    String toString(){
        return name;
    }

    void visit(ExpressionVisitor visitor){
        for(ClassMember cm in members){
            cm.visit(visitor);
        }
    }

    Iterable<FieldDecl> get fields {
        return members.where(m => m is FieldDecl).map(m => m as FieldDecl);
    }
    Iterable<MethodDecl> get methods {
        return members.where(m => m is MethodDecl).map(m => m as MethodDecl);
    }

    void validate(ValidationContext ctx, Integer phase) {
        D3ELogger.info('Validating : ' + name);
        ctx.dataType = type;
        if(phase == 0) {
            if(generics != null){
                ExpressionValidationUtil.validateTypeParams(generics, ctx);
                generics.resolveRawTypes(ctx, type, null, null).forEach((i) => type.typeVars.add(i));
            }
            if(extendType != null) {
                ctx.validateType(extendType);
                type.extends = extendType.resolvedType;
            }
            for(DataType i in impls){
                ctx.validateType(i);
                type.impls.add(i.resolvedType);
            }
            for(DataType i in ons){
                ctx.validateType(i);
                //type.impls.add(i.resolvedType);
            }
            for(DataType i in mixins){
                ctx.validateType(i);
            }
        }

        for(ClassMember m in members) {
            m.validate(ctx, phase);
        }
    }
    void register(ValidationContext ctx) {
        for(ClassMember cm in members){
            cm.cls = this;
        }
        type = ClassType(name: name);
        type.cls = this;
        ctx.addToCurrent(type);
    }
} 