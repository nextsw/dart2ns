server class Library implements TypeRegistry {
    String fullPath;
    String packagePath;
    String id;
    Library parent;
    List<Import> imports = [];
    List<Export> exports = [];
    List<TopDecl> objects = [];
    List<Part> parts = [];
    String partOf;

    Map<String, PropType> types = Map();

    Map<String, TopDecl> cache = Map();
    Set<String> notFound = Set();

    Library({this.parent, this.fullPath, this.packagePath});
    

    TopDecl get(String name) {
        if(name == null){
            return null;
        }
        if(name.startsWith('__') || notFound.contains(name)){
            return null;
        }
        TopDecl obj = cache.get(name);
        if(obj != null) {
            return obj;
        }
        obj = _getInternal(name, Set(), true);
        if(obj != null) {
            cache.set(name, obj);
        } else {
            notFound.add(name);
        }
        return obj;
    }
    TopDecl _getInternal(String name, Set<Library> checked, Boolean checkImports) {
        if(checked.contains(this)) {
            return null;
        }
        D3ELogger.info('Checking for "'+ name +'" in ' + packagePath);
        // checked.add(this);
        TopDecl top = objects.firstWhere(o => o.name == name);
        if(top == null) {
            // Check in Exports
            for(Export e in exports){
                if(e.show.isNotEmpty && !e.show.contains(name)) {
                    continue;
                }
                top = e.lib._getInternal(name, checked, false);
                if(top != null && e.hide.contains(name)) {
                    top = null;
                }
                if(top != null) {
                    break;
                }
            }

            if(checkImports) {
                // Check in Imports 
                for(Import e in imports){
                    
                    if(e.show.isNotEmpty && !e.show.contains(name)) {
                        continue;
                    }
                    top = e.lib._getInternal(name, checked, false);
                    if(top != null && e.hide.contains(name)) {
                        top = null;
                    }
                    if(top != null) {
                        break;
                    }
                }
            }
        }
        return top;
    }

    void subs(List<TopDecl> libs, Set<Library> collected) {
        if(collected.contains(this)) {
            return;
        }
        collected.add(this);
        for(Part p in parts){
            p.lib.subs(libs, collected);
        }
        for(Export p in exports){
            List<TopDecl> exported = List();
            p.lib.subs(exported, collected);
            if(p.hide.isNotEmpty) {
                for(TopDecl top in exported){
                    if(p.hide.contains(top.name)){
                        continue;
                    }
                    libs.add(top);
                }
            } else if(p.show.isNotEmpty) {
                for(TopDecl top in exported){
                    if(p.show.contains(top.name)){
                        libs.add(top);
                    }
                }
            } else {
                libs.addAll(exported);
            }
        }
        libs.addAll(objects);
    }

    void resolveFields(ResolveContext context) {
        D3ELogger.info('Resolving fields in Library: ' + packagePath);
        context.currentLib = this;
        for(TopDecl obj in objects) {
            if(obj is FieldDecl) {
                (obj as FieldDecl).resolve(context);
            } else if (obj is ClassDecl) {
                (obj as ClassDecl).resolveFields(context);
            }
        }
    }
    void resolveMethods(ResolveContext context) {
        D3ELogger.info('Resolving methods in Library: ' + packagePath);
        context.currentLib = this;
        for(TopDecl obj in objects) {
            if(obj is MethodDecl) {
                (obj as MethodDecl).resolve(context);
            } else if (obj is ClassDecl) {
                (obj as ClassDecl).resolveMethods(context);
            }
        }
    }

    void collectUsedTypes(List<DataType> list) {
        for(TopDecl obj in objects) {
            obj.collectUsedTypes();
            list.addAll(obj.usedTypes);
        }
    }

    void simplify(Simplifier s){
        for(TopDecl obj in objects){
            obj.simplify(s);
        }
    }
    void visit(ExpressionVisitor visitor){
        for(TopDecl obj in objects){
            obj.visit(visitor);
        }
    }

    PropType getType(String name){
        return types.get(name);
    }

    void addType(PropType type){
        types.set(type.name, type);
    }

    void validate(){
        ValidationContext ctx = ValidationContext(this);
        for(TopDecl top in objects) {
            top.register(ctx);
        }
        D3ELogger.info('Validating : ' + packagePath);
        for(TopDecl top in objects) {
            top.validate(ctx, 0);
        }
        for(TopDecl top in objects) {
            top.validate(ctx, 1);
        }
    }

    void addAll(List<TopDecl> list) {
        for(TopDecl i in list){
            i.lib = this;
        }
        objects.addAll(list);
    }

}