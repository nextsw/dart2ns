server class MethodCall extends Statement {
    String name;
    List<DataType> typeArgs = [];
    List<Argument> positionArgs = [];
    List<NamedArgument> namedArgs = [];
    Boolean checkNull;
    Boolean notNull;
    Expression on;
    String onTypeName;
    MethodDecl resolvedMethod;
    FunctionType resolvedFunctionType;

    MethodCallType callType;
    PropType staticClass;
    MethodCall({
        this.name,
        this.typeArgs,
        this.positionArgs,
        this.namedArgs,
        this.onTypeName,
    });


    void resolve(ResolveContext context) {
        callType = ERROR;
        if(name == 'assert') {
            resolvedType = context.statementType;
            callType = Assert;
            if(positionArgs.isNotEmpty){
                Expression exp = positionArgs.first.arg;
                if(exp is LambdaExpression) {
                    context.expectedType = FunctionType(
                        returnType: ValueType('bool'),
                    );
                } 
                exp.resolve(context);
            }
            return;
        }
        if(name == 'this' && context.instanceClass.isExtension) {
            DataType on = context.instanceClass.ons.first;
            Typedef def = context.currentLib.get(on.name) as Typedef;
            resolvedType = def.fnType.returnType;
            callType = FunctionMethod;
            return;
        }
        ClassDecl onType = null;
        Boolean onLibrary = false;
        if(on != null) {
            on.resolve(context);
            if(on.resolvedType == context.libraryType) {
                onLibrary = true;
            } else if(on.resolvedType == context.typeType) {
                if(!(on is FieldOrEnumExpression)){
                    context.error('Mist be FE Exp');
                    resolvedType = context.ofUnknownType();
                    return;
                }
                String typeName = (on as FieldOrEnumExpression).name;
                TopDecl top = context.currentLib.get(typeName);
                if(top is ClassDecl){
                    onType = top as ClassDecl;
                } else if(top is Enum) {
                    onType = (top as Enum).toClassDecl();
                }
            } else  if(on.resolvedType is ValueType) {
                TopDecl top = context.currentLib.get(on.resolvedType.name);
                if(top is ClassDecl) {
                    onType = top as ClassDecl;
                }
            }
        } else {
            if(context.instanceClass != null 
                && context.getMember(context.instanceClass, name) != null){
                onType = context.instanceClass;
            }
            if(onTypeName != null) {
                TopDecl top = context.currentLib.get(onTypeName);
                if(top is ClassDecl){
                    onType = top as ClassDecl;
                }
            }
        }
        DataType scopeType = context.scope?.get(name);
        if(onType != null) {
            MethodDecl md = context.getMember(onType, name, filter: AllMethods) as MethodDecl;
            if(md == null){
                md = onType.method(onType.name + '.' + name);
            }
            if(md != null) {
                if(md.getter) {
                    // we are calling a getters return type
                    if(md.returnType is FunctionType) {
                        resolvedFunctionType = md.returnType as FunctionType;
                        callType = FunctionMethod;
                    } else {
                        TopDecl top = context.currentLib.get(md.returnType.name);
                        if(top is Typedef ){
                            Typedef def = top as Typedef;
                            resolvedFunctionType = def.fnType;
                            callType = FunctionMethod;
                        } else {
                            context.error('We can not call non function type getters');
                            resolvedType = context.ofUnknownType();
                        }
                    }
                } else if(md.returnType == null) {
                    //Assuming it is constuctor
                    resolvedType = ValueType(onType.name);
                    if(md.factoryName == name){
                        callType = FactoryConstructor;
                    } else {
                        callType = Constructor;
                    }
                } else {
                    resolvedType = context.resolveType(onType, md.cls, md.returnType);
                    if(md.static) {
                        callType = StaticMethod;
                    } else {
                        callType = InstanceMethod;
                    }
                }
                resolvedMethod = md;
            } else {
                // Error
                resolvedType = context.ofUnknownType();
            }
        } else if(onLibrary) {
            if(!(on is FieldOrEnumExpression)){
                context.error('Mist be FE Exp');
                resolvedType = context.ofUnknownType();
            } else {
                String importName = (on as FieldOrEnumExpression).name;
                Library libToCheck = context.currentLib;
                TopDecl topCm = libToCheck.get(name);
                if(topCm is MethodDecl) {
                    MethodDecl md = topCm as MethodDecl;
                    resolvedType = md.returnType;
                    resolvedMethod = md;
                    callType = LibraryMethod;
                } else if(topCm is ClassDecl){
                    ClassDecl cls = topCm as ClassDecl;
                    ClassMember cm = context.getMember(cls, name);
                    if(cm is MethodDecl) {
                        resolvedMethod = cm as MethodDecl;
                    }
                    resolvedType = ValueType(cls.name);
                    callType = InstanceMethod;
                } else {
                    resolvedType = context.ofUnknownType();
                }
            }
        } else if(scopeType != null) {
            if(scopeType is FunctionType) {
                resolvedType = (scopeType as FunctionType).returnType;
                callType = FunctionMethod;
            } else {
                String cls = context.instanceClass?.name;
                String method = context.method?.name;
                String inType = onType?.name;
                context.error('Referend method is not Function type: ' + name + ' in ' + inType + ' Cls: ' + cls +' Method: ' + method);
                resolvedType = context.ofUnknownType();
            }
        } else {
            TopDecl td = context.currentLib.get(name);
            if(td is MethodDecl) {
                MethodDecl md = td as MethodDecl;
                resolvedType = md.returnType;
                resolvedMethod = md;
                callType = LibraryMethod;
                //TODO need to resolve on method type generics
            } else if(td is ClassDecl){
                resolvedType = ValueType(name);
                resolvedMethod = (td as ClassDecl).method(name);
                callType = Constructor;
            } else {
                String cls = context.instanceClass?.name;
                String method = context.method?.name;
                String inType = onType?.name;
                context.error('No method found: ' + name + ' in ' + inType + ' Cls: ' + cls +' Method: ' + method);
                resolvedType = context.ofUnknownType();
            }
        }
        
        Integer x = 0;
        for(Argument arg in positionArgs) {
            if(resolvedFunctionType != null) {
                MethodParam p = resolvedFunctionType.params.get(x);
                if(p!= null) {
                    arg.resolvedType = p.dataType;
                    context.expectedType = arg.resolvedType;
                }else {
                    context.expectedType = context.ofUnknownType();
                }
            } else if(resolvedMethod != null) {
                MethodParam p = resolvedMethod.getParamAt(x);
                if(p!= null){
                    arg.resolvedType = p.dataType;
                    context.expectedType = arg.resolvedType;
                }else {
                    context.expectedType = context.ofUnknownType();
                }
            } else {
                context.expectedType = context.ofUnknownType();
            }
            arg.arg.resolve(context);
        }
        for(NamedArgument arg in namedArgs) {
            if(resolvedMethod != null) {
                MethodParam p = resolvedMethod.getParam(arg.name);
                if(p != null) {
                    arg.resolvedType = resolvedMethod.getParam(arg.name).dataType;
                    context.expectedType = arg.resolvedType;
                } else{
                    context.expectedType = context.ofUnknownType();
                }
            } else {
                context.expectedType = context.ofUnknownType();
            }
            arg.value.resolve(context);
        }
        if(resolvedMethod != null && this.namedArgs.isNotEmpty) {
            for(Integer y = this.positionArgs.length; y < resolvedMethod.allParams.length; y++) {
                MethodParam param  = resolvedMethod.allParams.get(y);
                NamedArgument arg = namedArgs.firstWhere(n => n.name == param.name);
                if(arg == null) {
                    namedArgs.add(NamedArgument(
                        name: param.name,
                        value: param.defaultValue ?? makeDefaultValue(param.dataType),
                    ));
                } else {
                    namedArgs.add(arg);
                }
            }
        }
    }
    void collectUsedTypes(List<DataType> types) {
        if(on != null) {
            on.collectUsedTypes(types);
        }
        for(Argument arg in positionArgs) {
            arg.arg.collectUsedTypes(types);
        }
        for(NamedArgument arg in namedArgs) {
            arg.value.collectUsedTypes(types);
        }
    }

    void simplify(Simplifier s) {
        if(checkNull) {
            TerinaryExpression ter = TerinaryExpression(
                condition: BinaryExpression(
                    op: '==',
                    left: on,
                    right: NullExpression(),
                ),
                ifTrue: NullExpression(),
                ifFalse: this,
            );
            checkNull = false;
            s.add(ter);
            s.markDelete();
        } else {
            on = s.makeSimple(on);
            for(Argument arg in positionArgs) {
                arg.arg = s.makeSimple(arg.arg);
            }
            for(NamedArgument arg in namedArgs) {
                arg.value = s.makeSimple(arg.value);
            }
        }
    }

    Expression makeDefaultValue(DataType type){
        if(type == null) {
            return NullExpression();
        } else if(type.name == 'int') {
            return LiteralExpression(
                type: LiteralType.TypeInteger,
                value: '0',
            );
        } else if(type.name == 'double') {
            return LiteralExpression(
                type: LiteralType.TypeDouble,
                value: '0.0',
            );
        } else if(type.name == 'num') {
            return LiteralExpression(
                type: LiteralType.TypeInteger,
                value: '0',
            );
        } else if(type.name == 'bool') {
            return LiteralExpression(
                type: LiteralType.TypeBoolean,
                value: 'false',
            );
        } else {
            return NullExpression();
        }
    }

    void visit(ExpressionVisitor visitor) {
        visitor.visit(on);   
        for(Argument arg in positionArgs) {
            visitor.visit(arg.arg);
        }
        for(NamedArgument arg in namedArgs) {
            visitor.visit(arg.value);
        }
    }
}